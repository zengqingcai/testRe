java 基础：
类：
构造器可以被修饰为public proteced default private 
但是不能被 final native static synchronized修饰
构造器没有写使用默认的构造器，子类的构造器中没有写父类的构造器，默认使用父类默认的构造器
子类继承父类，子类实例化创造构造器前必须先创建父类的构造器

构造器就是构造方法，能够被重载（同类中不同参数列表的构造器），
不能够被重写（子类使用super方法可以调用）。不能被继承，因为能够调用，但是不能重写。

重载是针对同类的
重写针对子父类，接口和实现类，抽象类和实现类
java 多态的表现形式：
方法的重载和覆盖
多态是同一个行为具有多个不同表现形式或形态的能力。
多态就是同一个接口，使用不同的实例而执行不同操作

final 和 adstract相反
被fina修饰的变量成常量，可以被继承
被final修饰的方法不能被重写，可以被继承
被fianl修饰的类不能被继承
adstract可以被继承而且必须被继承否则就没意义。
JAVA中String为final修饰类
String类作为final类型，那String将不能被继承，也不能被重写，那使用String类的效率和安全性将会得到保障

被static修饰的方法，在类里声明具有唯一性，通过类的创建而存在的，而不是通过new，实例化对象存在，不是对象所有，
父类中的静态成员变量和方法是可以被子类继承的,但是不能被自己重写,无法形成多态

匿名内部类：
new 父类构造器（参数列表）|实现接口（）|抽象类  
{  
	//匿名内部类的类体部分  
}
匿名内部类是唯一一种无构造方法类。大部分匿名内部类是用于接口回调用的

Student st = new Student();
Student.Man sm = new Student().new Man();
Student.MM mm = new Student.MM();

静态内部类和非静态内部类区别汇总

一、非静态内部类：

1、变量和方法不能声明为静态的。(类的编译顺序：外部类--静态方法或属性--内部类，如果内部类声明为静态的，造成编译顺序冲突。个人理解)

2、实例化的时候需要依附在外部类上面。比如：B是A的非静态内部类，实例化B，则：A.B b = new A().new B();

3、内部类可以引用外部类的静态或者非静态属性或者方法。

 

二、静态内部类：

1、属性和方法可以声明为静态的或者非静态的。

2、实例化静态内部类：比如：B是A的静态内部类，A.B b = new A.B();

3、内部类只能引用外部类的静态的属性或者方法。

4、如果属性或者方法声明为静态的，那么可以直接通过类名直接使用。比如B是A的静态内部类，b（）是B中的一个静态属性，则可以：A.B.b();

 

三、关于java静态方法的相关总结：

一个类的静态方法只能访问静态属性（静态方法是属于类的，而普通方法是属于对象的。）

一个类的静态方法不能够直接调用非静态方法；
如访问控制权限允许，static 属性和方法可以使用类名加“.”方式调用；当然也可以使用实例加“.”方式调用；
静态方法中不存在当前对象，因而不能使用“this”，当然也不能使用”super”；
静态方法不能被非静态方法覆盖；
构造方法不允许声明为 static 的；
局部变量不能使用static修饰；

接口中的方法
不能被final static修饰
变量必须 public static final 修饰并且初始化
public   String s=""; 或者public static s ="";或者 public final   String s="";
接口是特殊的抽象类
接口和抽象类的区别
1、接口可以多继承，抽象类不行
2、接口里面的所有方法都是抽象方法，抽象类可以有普通方法，但是至少要有一个抽象方法
4、接口里面的变量都是static，抽象类里面可以有成员变量，静态成员变量
5、抽象类可以实现接口，抽象类可以继承抽象类，接口可以继承接口（一个接口可以继承多个接口）

Java对象的4大特性
抽象 封装 多态 继承
它们分别的好处


java 运算有一般数据运算，还有位运算 & | ^ 》 《 
整形数字有二进制 十进制 八进制 16进制的

内置数据类型 byte short int long float double char  boolean
引用数据类型 enum String 
一个字符一个字节 一个汉子两个字符两个字节

java 内存管理
java 对象hashcode equals 方法
synchronized 和 volatile 修饰符，主要用于线程的编程。
synchronized 关键字声明的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符
synchronized 同步了方法，使得它多线程安全，但是效率会低
java 栈堆
Java 线程
java io流，总体分为字节流，字符流，数据源可以是内存 硬盘 网络上的对象
java 网络编程 socket 
java 数据结构
java jdbc
java 算法，加密算法
java jms
Java jvm
Java servlet
java 23个模式


java 对象转byte[] ,String 也可以转byte[]  首先对象要继承Serializable接口

静态的成员变量与非静态的成员变量的区别：
1. 作用上的区别：
1. 静态的成员变量的作用共享一个 数据给所有的对象使用。
2. 非 静态的成员变量的作用是描述一类事物的公共属性。
2. 数量与存储位置上的区别：
1. 静态成员变量是存储方法 区内存中，而且只会存在一份数据。
2. 非静态的成员变量是存储在堆内存中，有n个对象就有n份数据。
3. 生命周期的区别：
1. 静态的成员变量数据是随着类的加载而存在，随着类文件的消失而消失。
2.非静态的成员数据是随着对象的创建而存在，随着 对象被垃圾回收器回收而消失。

Java 序列化也叫持久化，把内存中的对象持久化到硬盘中
关于序列化，常又称为持久化，将其写入磁盘中。
进而对于编码规则来说：
任一一个实体类必须要去实现 Serializable 接口，方便以后将该类持久化，或者将其用于转为字节数组，用于网络传输。
对于一个实体类，不想将所有的属性都进行序列化，有专门的关键字 transient：